\documentclass[a4paper,12pt, titlepage]{report}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX
\usepackage{placeins}
\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float

\usepackage[a4paper,width=150mm,top=20mm,bottom=20mm]{geometry}
\usepackage{lmodern}  % for bold teletype font
\usepackage{amsmath}  % for \hookrightarrow
\usepackage{xcolor}   % for \textcolor
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
\fancyfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\graphicspath{ {./images/} }

\def\uczelnia{{Uniwersytet Kardynała Stefana Wyszyńskiego w~Warszawie}\\
Wydział Matematyczno-Przyrodniczy \\ Szkoła Nauk Ścisłych}
\def\nralbumu{107418}
\title{Przetwarzanie obrazów\\Sprawozdanie z laboratorium}
\author{Małgorzata Wiśniewska}
\date{Warszawa, 2020} 

\begin{document}
\maketitle
\tableofcontents
\chapter{Wstęp}
\section{Format obrazów}
\section{Instrukcja obsługi programu}

\chapter{Operacje ujednolicania obrazów}
Operacje ujednolicania obrazów dzieli się na dwa etapy. Pierwszym etapem jest ujednolicanie geometryczne, drugim jest ujednolicenie rozdzielczościowe. W prezentowanym programie ujednolicane są dwa obrazy, w taki sposób, że mniejszy z nich jest doprowadzany do takiego samego rozmiaru jak większy. Skutkuje to wygenerowaniem nowego obrazu o zwiększonej ilości piksli niż początkowa wartość. Dzięki zastosowaniu tego typu ujednolicania w efekcie nie następuje widoczny spadek jakości. 
\section{Ujednolicanie obrazów szarych geometryczne}
\subsection*{Opis algorytmu}
\par Operacje geometrycznego ujednolicania polega na wyrównaniu liczby piksli w kolumnach i wierszach w obu obrazach, poprzez zwiększenie liczby piksli w kolumnach i wierszach mniejszego z obrazów.
\begin{enumerate}
\item Wybierz największą wysokość i największą szerokość spośród obu obrazów.
\item Jeśli dany obraz ma mniejszą wysokość lub szerokość, wypełnij różnicę pikslami o wartości 1, tak, żeby wysokość i szerokość obu obrazów była równa.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 256x256]{{\includegraphics[width=0.4\textwidth]{./RawPictures/fotograf.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \caption{Obrazy wejściowe}%
    \label{fig:geo_before_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 512x512]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/11/fotograf_rys.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \caption{Obrazy wyjściowe}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 369x480]{{\includegraphics[width=0.4\textwidth]{./RawPictures/AndrzejZamoyski.png} }}%
    \qquad
    \subfloat[Obraz 2: 623x640]{{\includegraphics[width=0.4\textwidth]{./RawPictures/kobietaDziecko.png} }}%
    \caption{Obrazy wejściowe}%
    \label{fig:geo_before_grey2}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1:  623x640]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/11/AndrzejZamoyski_kobietaDziecko.png} }}%
    \qquad
    \subfloat[Obraz 2:  623x640]{{\includegraphics[width=0.4\textwidth]{./RawPictures/kobietaDziecko.png} }}%
    \caption{Obrazy wyjściowe}%
    \label{fig:geo_after_grey2}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def geoUnificationGrey(self):
	# porownaj wielkosc obrazow, jezeli sa tego samego rozmiaru nie rob nic
	if self.biggerPicture == 0 and self.smallerPicture == 0:
		print('Both pictures have the same size')
		return 0
	# stworz tablice zer do zapisu efektu algorytmu
	result = np.zeros((self.maxLength, self.maxWidth), np.uint8)
	startWidthIndex = int(round((self.maxWidth - self.minWidth) / 2))
	startLengthIndex = int(round((self.maxLength - self.minLength) / 2))
	for w in range(0, self.minWidth):
		for l in range(0, self.minLength):
			result[l + startLengthIndex, w + startWidthIndex] = self.matrix[l, w]
	#zapisz zunifikowany obraz
	path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '.png'
	self.saver.savePictureFromArray(result, 'L', path)
\end{lstlisting}

\section{Ujednolicanie obrazów szarych rozdzielczościowe}
\subsection*{Opis algorytmu}
\par Operacja rozdzielczościowego ujednolicania obrazów następuje po ujednoliceniu geometrycznym obrazów wejściowych. Polega na wypełnieniu obrazu pikslami. Brakujące piksle powinny zostać zinterpolowane.
\begin{enumerate}
\item Wypełnij cały obraz pikslami o znanej wartości zachowując pewien odstęp między nimi, gdzie odstępem będą piksle o wartości 0.
\item Każdemu pikslowi o nieznanej wartości przypisz średnią wartość znanych (>0) piksli z jego bezpośredniego otoczenia.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 512x512]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/11/fotograf_rys.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \caption{Obrazy wejściowe po ujednoliceniu geometrycznym}%
    \label{fig:example}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 512x512]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_rys_withoutInterpolation.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \caption{Obrazy wyjściowe bez interpolacji}%
    \label{fig:example}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 512x512]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_rys_withInterpolation.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \caption{Obrazy wyjściowe po interpolacji}%
    \label{fig:example}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def resolutionUnificationGrey(self):
    print('Beginning of resolution unification for two grey pictures.')
    if self.biggerPicture == 0 and self.smallerPicture == 0:
        print('Both pictures have the same size')
        return 0
    scaleFactorLength = float(self.maxLength / self.minLength)
    scaleFactorWidth = float(self.maxWidth / self.minWidth)
    result = np.zeros((self.maxLength, self.maxWidth), np.uint8)
    for l in range(self.minLength):
        for w in range(self.minWidth):
            if w % 2 == 0:
                pomL = int(scaleFactorLength * l)
                pomW = int(round(scaleFactorWidth * w))
                result[pomL, pomW] = self.matrix[l, w]
            elif w % 2 == 1:
                pomL = int(round(scaleFactorLength * l))
                pomW = int(scaleFactorWidth * w)
                result[pomL, pomW] = self.matrix[l, w]
    # zapisz obraz bez interpolacji
    path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '_withoutInterpolation.png'
    self.saver.savePictureFromArray(result, 'L', path)
    # interpolacja
    for l in range(self.maxLength):
        for w in range(self.maxWidth):
            value = 0
            count = 0
            if result[l, w] == 0:
                for lOff in range(-1, 2):
                    for wOff in range(-1, 2):
                        lSave = l if ((l + lOff) > (self.maxLength - 2)) | ((l + lOff) < 0) else (l + lOff)
                        wSave = w if ((w + wOff) > (self.maxWidth - 2)) | ((w + wOff) < 0) else (w + wOff)
                        if result[lSave, wSave] != 0:
                            value += result[lSave, wSave]
                            count += 1
                result[l, w] = value / count
    # zapisz obraz po interpolacji
    path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '_withInterpolation.png'
    self.saver.savePictureFromArray(result, 'L', path)
    print('Finished resolution unification.')
\end{lstlisting}

\section{Ujednolicanie obrazów RGB geometryczne}
\subsection*{Opis algorytmu}
\par Operacje geometrycznego ujednolicania polega na wyrównaniu liczby piksli w kolumnach i wierszach w obu obrazach, poprzez zwiększenie liczby piksli w kolumnach i wierszach mniejszego z obrazów.
\begin{enumerate}
\item Wybierz największą wysokość i największą szerokość spośród obu obrazów.
\item Jeśli dany obraz ma mniejszą wysokość lub szerokość, wypełnij różnicę pikslami o wartości 1 dla każdego z kanałów (R,G,B), tak, żeby wysokość i szerokość obu obrazów była równa.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/morze.png} }}%
    \qquad
    \subfloat[Obraz 2: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \caption{Obrazy wejściowe}%
    \label{fig:geo_before_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/13/morze_stogi.png} }}%
    \qquad
    \subfloat[Obraz 2: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \caption{Obrazy wyjściowe}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 256x256]{{\includegraphics[width=0.4\textwidth]{./RawPictures/kawa.png} }}%
    \qquad
    \subfloat[Obraz 2: 512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/morze.png} }}%
    \caption{Obrazy wejściowe}%
    \label{fig:geo_before_grey2}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1:  512x512]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/13/kawa_morze.png} }}%
    \qquad
    \subfloat[Obraz 2:  512x512]{{\includegraphics[width=0.4\textwidth]{./RawPictures/morze.png} }}%
    \caption{Obrazy wyjściowe}%
    \label{fig:geo_after_grey2}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def geoUnificationRGB(self):
    if self.biggerPicture == 0 and self.smallerPicture == 0:
        print('Both pictures have the same size')
        return 0
    # stworz tablice z zerami jako odstawe dla unifikacji
    result = np.full((self.maxLength, self.maxWidth, 3), 0, np.uint8)
    startWidthIndex = int(round((self.maxWidth - self.minWidth) / 2))
    startLengthIndex = int(round((self.maxLength - self.minLength) / 2))
    for w in range(0, self.minWidth):
        for l in range(0, self.minLength):
            result[l + startLengthIndex, w + startWidthIndex] = self.matrix[w, l]
    # zapisz zunifikowany obraz
    path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '.png'
    self.saver.savePictureFromArray(result, 'RGB', path)
\end{lstlisting}

\section{Ujednolicanie obrazów RGB rozdzielczościowe}
\subsection*{Opis algorytmu}
\par Operacja rozdzielczościowego ujednolicania obrazów następuje po ujednoliceniu geometrycznym obrazów wejściowych. Polega na wypełnieniu obrazu pikslami. Brakujące piksle powinny zostać zinterpolowane.
\begin{enumerate}
\item Wypełnij cały obraz pikslami o znanej wartości zachowując pewien odstęp między nimi, gdzie odstępem będą piksle o wartości 0.
\item Każdemu pikslowi (ze wszystkich kanałów - R, G, B) o nieznanej wartości przypisz średnią wartość znanych (>0) piksli z jego bezpośredniego otoczenia.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/13/morze_stogi.png} }}%
    \qquad
    \subfloat[Obraz 2: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \caption{Obrazy wejściowe po ujednoliceniu geometrycznym}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withoutInterpolation.png} }}%
    \qquad
    \subfloat[Obraz 2: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \caption{Obrazy wyjściowe bez interpolacji}%
    \label{fig:example}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat[Obraz 1: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withInterpolation.png} }}%
    \qquad
    \subfloat[Obraz 2: 1025x1025]{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \caption{Obrazy wyjściowe po interpolacji}%
    \label{fig:example}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def resolutionUnificationGrey(self):
    print('Beginning of resolution unification for two grey pictures.')
    if self.biggerPicture == 0 and self.smallerPicture == 0:
        print('Both pictures have the same size')
        return 0
    scaleFactorLength = float(self.maxLength / self.minLength)
    scaleFactorWidth = float(self.maxWidth / self.minWidth)
    result = np.zeros((self.maxLength, self.maxWidth), np.uint8)
    for l in range(self.minLength):
        for w in range(self.minWidth):
            if w % 2 == 0:
                pomL = int(scaleFactorLength * l)
                pomW = int(round(scaleFactorWidth * w))
                result[pomL, pomW] = self.matrix[l, w]
            elif w % 2 == 1:
                pomL = int(round(scaleFactorLength * l))
                pomW = int(scaleFactorWidth * w)
                result[pomL, pomW] = self.matrix[l, w]
    # zapisz obraz bez interpolacji
    path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '_withoutInterpolation.png'
    self.saver.savePictureFromArray(result, 'L', path)
    # interpolacja
    for l in range(self.maxLength):
        for w in range(self.maxWidth):
            value = 0
            count = 0
            if result[l, w] == 0:
                for lOff in range(-1, 2):
                    for wOff in range(-1, 2):
                        lSave = l if ((l + lOff) > (self.maxLength - 2)) | ((l + lOff) < 0) else (l + lOff)
                        wSave = w if ((w + wOff) > (self.maxWidth - 2)) | ((w + wOff) < 0) else (w + wOff)
                        if result[lSave, wSave] != 0:
                            value += result[lSave, wSave]
                            count += 1
                result[l, w] = value / count
    # zapisz obraz po interpolacji
    path = self.ex + self.smallerPictureName + '_' + self.biggerPictureName + '_withInterpolation.png'
    self.saver.savePictureFromArray(result, 'L', path)
    print('Finished resolution unification.')
\end{lstlisting}

\chapter{Operacje sumowania arytmetycznego obrazów szarych}
Operacje arytmtyczne między pikslami dwóch obrazów sa wykorzystywane w wielu działach przetwarzania obrazów. Przeprowadza się je wykonując operacje na pojedynczych pikslach. Po operacjach arytmetycznych zwykle konieczne jest normalizowanie obrazu wynikowego. W zadaniach do normalizacji wykorzystano wzór:
\[f_{norm}=Z_{rep}[(f-f_{min})/(f_{max}-f_{min})]\]

\section{Sumowanie obrazów szarych z określoną stałą}
\subsection*{Opis algorytmu}
\par Algorytm sumowowania obrazu szarego z określoną stałą polega na daodaniu do każdej wartości pojedynczego piksla określonej stałej. Po operacji sumowania następuje normalizacja obrazu.
\begin{enumerate}
\item Policz sumy wartości każdego piksla ze stałą. Jeżeli suma przekracza 255 to konieczne jest
\begin{itemize}
\item Wybranie największej sumę piksla ze stałą - \(Q_{max}\) 
\item Obliczenie \(D_{max}\) ze wzoru: \(D_{max}[l,w]=(Q_{max}[l,w]-255)\)
\item Obliczenie \(X=D_{max}/255\)
\end{itemize}
\item Policz sumę ze wzoru: \(Q[l,w]=P[l,w]-(P[l, w]*X)+const-(const*X)\)
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/21/fotograf_constant_70.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/21/fotograf_constant_70_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po sumowaniu ze stałą 70, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/21/rys_constant_400.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/21/rys_constant_400_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po sumowaniu ze stałą 400, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def addConstGrey(self, constant):
    maxBitsColor = self.checkPictureBits(self.pic1)
    length, width, pictureName = self.pic1.getPictureParameters()
    matrix = self.pic1.getGreyMatrix()
    result = np.ones((length, width), np.uint8)
    sumMax = 0
    x = 0
    fmin = maxBitsColor
    fmax = 0
    for l in range(length):
        for w in range(width):
            added = matrix[l, w] + constant
            if sumMax < added:
                sumMax = added
    if sumMax > maxBitsColor:
        x = (sumMax - maxBitsColor) / maxBitsColor
    for l in range(length):
        for w in range(width):
            # Rounded up and assignment of value to the result matrix
            pom = (matrix[l, w] - (matrix[l, w] * x)) + (constant - (constant * x))
            result[l, w] = np.ceil(pom)
            # Search for maximum and minimum
            if fmin > pom:
                fmin = pom
            if fmax < pom:
                fmax = pom
    # save picture with added constant to png file (without normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
    for l in range(length):
        for w in range(width):
            result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))
    # save picture with added constant to png file (with normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Sumowanie dwóch obrazów szarych}
\subsection*{Opis algorytmu}
\par Algorytm sumowowania obrazu szarego z drugim obrazem szarym jest określone tylko o tych samych wymiarach \(MxN\) i strukturze ich macierzy. Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z  pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu. Po operacji sumowania następuje normalizacja obrazu. Operacja dodawania obrazów są użyteczne przy uśrednianiu obrazów, w celu zredukowania na nich szumu.
\begin{enumerate}
\item Policz sumy wartości każdego piksla obrazu pierwszego \(P1[l,w]\) z odpowiadającym pikslem drugiego obrazu \(P2[l,w]\). Jeżeli suma przekracza 255 to konieczne jest
\begin{itemize}
\item Wybranie największej sumy odpowiadających piksli dwóch obrazów - \(Q_{max}\) 
\item Obliczenie \(D_{max}\) ze wzoru: \(D_{max}[l,w]=(Q_{max}[l,w]-255)\)
\item Obliczenie \(X=D_{max}/255\)
\end{itemize}
\item Policz sumę ze wzoru: \[Q[l,w]=P1[l,w]-(P1[l,w]*X)+P2[l,w]-(P2[l,w]*X)\]
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/AndrzejZamoyski_rys_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/21/AndrzejZamoyski_added_rys.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/21/AndrzejZamoyski_added_rys_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/morze-szare_stogi-szare_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi-szare.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/21/morze-szare_added_stogi-szare.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/21/morze-szare_added_stogi-szare_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def addPictureGrey(self):
    if self.checkPictureBits(self.pic1) == self.checkPictureBits(self.pic2):
        maxBitsColor = self.checkPictureBits(self.pic2)
    # check if pictures have same sizes, if not unify them
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, pictureName1 = self.pic1.getPictureParameters()
    matrix1 = self.pic1.getGreyMatrix()
    length2, width2, pictureName2 = self.pic2.getPictureParameters()
    matrix2 = self.pic2.getGreyMatrix()
    pictureName1 = tempName

    sumMax = 0
    x = 0
    fmax = 0
    fmin = maxBitsColor

    result = np.zeros((length1, width1), np.uint8)

    for l in range(length1):
        for w in range(width1):
            added = int(matrix1[l, w]) + int(matrix2[l, w])
            if sumMax < added:
                sumMax = added

    if sumMax > maxBitsColor:
        x = (sumMax - maxBitsColor) / maxBitsColor

    for l in range(length1):
        for w in range(width1):
            # Rounded up and assignment of value to the result matrix
            pom = int(matrix1[l, w] - (matrix1[l, w] * x)) + int(matrix2[l, w] - (matrix2[l, w] * x))
            result[l, w] = np.ceil(int(pom))
            # Search for maximum and minimum
            if fmin > pom:
                fmin = pom
            if fmax < pom:
                fmax = pom

    # save picture with added constant to png file (without normalization)
    path = self.ex + str(pictureName1) + '_added_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    normalized = np.zeros((length1, width1), np.uint8)
    for l in range(length1):
        for w in range(width1):
            normalized[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))

    # save picture with added constant to png file (with normalization)
    path = self.ex + str(pictureName1) + '_added_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mnożenie obrazów szarych przez określoną stałą}
\subsection*{Opis algorytmu}
\par Algorytm mnożenia obrazu szarego przez określoną stałą polega na przemnożeniu każdego elementu obrazu (piksla) przez określoną stałą (skalar). Dla wszystkich piksli w obrazie wykonaj:
\begin{enumerate}
\item Jeżeli wartość piksla jest równa 255 to składowa wynikowa otrzymuje wartość stałej.
\item Jeżeli wartość piksla jest równa 0 to składowa wynikowa otrzymuje wartość 0.
\item Jeżeli wartość piksla jest inna niż 255 lub 0 to składowa wynikowa otrzymuje wartość poprzez pomnożenie wartości piksla przez skalar, podzielenie przez 255 i zaokrąglenie do liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/22/fotograf_constant_100.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/22/fotograf_constant_100_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po sumowaniu ze stałą 100, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/22/rys_constant_100.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/22/rys_constant_100_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po sumowaniu ze stałą 100, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def multiplyConstGrey(self, constant):
    maxBitsColor = self.checkPictureBits(self.pic1)
    length, width, matrix, pictureName = self.getPictureParameters(self.pic1)
    result = np.ones((length, width), np.uint8)
    fmin = maxBitsColor
    fmax = 0
    for l in range(length):
        for w in range(width):
            pom = matrix[l, w]
            if pom == maxBitsColor:
                result[l, w] = maxBitsColor
            elif pom == 0:
                result[l, w] = 0
            else:
                result[l, w] = np.ceil(((matrix[l, w] * constant) / maxBitsColor))
            # Search for maximum and minimum
            if fmin > result[l, w]:
                fmin = result[l, w]
            if fmax < result[l, w]:
                fmax = result[l, w]
    # save picture with added constant to png file (without normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
    for l in range(length):
        for w in range(width):
            result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))
    # save picture with added constant to png file (with normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mnożenie obrazu przez inny obraz}
\subsection*{Opis algorytmu}
\par Algorytm mnożenia obrazu szarego przez drugi szary obraz o tych samych wymiarach \(MxN\) i strukturze ich macierzy polega na przemnożeniu wartości piksla z pierwszego obrazu przez wartość odpowiadającego piksla z drugiego obrazu. Po operacji mnożenia następuje normalizacja obrazu. Dla każdego piksla pierwszego obrazu wykonaj następujące czynności:
\begin{enumerate}
\item Jeżeli wartość piksla \(P1[l,w]\) jest równa 255 to składowa wynikowa otrzymuje wartość odpowiadającego piksla drugiego obrazu \(P2[l,w]\).
\item Jeżeli wartość piksla \(P1[l,w]\) jest równa 0 to składowa wynikowa otrzymuje wartość 0.
\item Jeżeli wartość piksla \(P1[l,w]\) jest inna niż 255 lub 0 to składowa wynikowa otrzymuje wartość poprzez pomnożenie wartości piksla \(P1[l,w]\) przez odpowiadający piksel \(P2[l,w]\), podzielenie przez 255 i zaokrąglenie do liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_rys_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/22/fotograf_multiplied_rys.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/22/fotograf_multiplied_rys_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_AndrzejZamoyski_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/AndrzejZamoyski.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/22/fotograf_multiplied_AndrzejZamoyski.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/22/fotograf_multiplied_AndrzejZamoyski_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def multiplyPicturesGrey(self):
    if self.checkPictureBits(self.pic1) == self.checkPictureBits(self.pic2):
        maxBitsColor = self.checkPictureBits(self.pic2)
    # check if pictures have same sizes, if not unify them
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
    length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
    pictureName1 = tempName

    result = np.ones((length1, width1), np.uint8)

    fmin = maxBitsColor
    fmax = 0

    for l in range(length1):
        for w in range(width1):
            if matrix1[l, w] == maxBitsColor:
                result[l, w] = matrix2[l, w]
            elif matrix1[l, w] == 0:
                result[l, w] = 0
            else:
                result[l, w] = np.ceil(((int(matrix1[l, w]) * int(matrix2[l, w])) / maxBitsColor))
            # Search for maximum and minimum
            if fmin > result[l, w]:
                fmin = result[l, w]

            if fmax < result[l, w]:
                fmax = result[l, w]

    # save picture multiplied by picture to png file (without normalization)
    path = self.ex + str(pictureName1) + '_multiplied_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length1):
        for w in range(width1):
            result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))

    # save picture multiplied by picture to png file (with normalization)
    path = self.ex + str(pictureName1) + '_multiplied_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mieszanie obrazów z określonym współczynnikiem}
\subsection*{Opis algorytmu}
\par Mieszanie dwóch obrazów polega na sumowaniu ich z wagami \(\alpha\) i \(1-\alpha\) według wzoru: \[f_{m}=f\alpha+f^{I}(1-\alpha)\] gdzie \(\alpha\in[0,1]\). Płynna zmiana parametru \(\alpha\) w przedziale \([0,1]\) powoduje efekt przechodzenia obrazu \(f\) w obraz \(f^{I}\).
\begin{enumerate}
\item Weź dwa obrazy szare o takim samym rozmiarze (po ujednoliceniu rozdzielczościowym) \(P_{1}\) i \(P_{2}\).
\item Określ współczynnik mieszania obrazów \(\alpha\) wyrażony jako liczba rzeczywista z przedziału \([0,1]\), gdzie 0 reprezentuje przezroczystość, a 1 reprezentuje nieprzezroczystość.
\item Dla wszystkich piksli w obrazach wejściowych wykonaj: \[Q[l,w]=\alpha*P_{1}[l,w]+(1-\alpha)*P_{2}[l,w]\]
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_rys_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/23/fotograf_blended_0.8_rys.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/23/fotograf_blended_0.8_rys_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po mieszaniu ze współczynnikiem \(\alpha=0.8\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_AndrzejZamoyski_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/AndrzejZamoyski.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/23/fotograf_blended_0.3_AndrzejZamoyski.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/23/fotograf_blended_0.3_AndrzejZamoyski_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz po mieszaniu ze współczynnikiem \(\alpha=0.3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
        resolutionUni = ResolutionUnificationGrey(self.name1, self.name2)
        resolutionUni.resolutionUnificationGrey()
        pic1Path, pic2Path = resolutionUni.getOutputPaths()
        pic1 = ImageHelper(pic1Path, self.pictureType)
        pic2 = ImageHelper(pic2Path, self.pictureType)
        return pic1, pic2
def blendPictures(self, alfa):
        if self.checkPictureBits(self.pic1) == self.checkPictureBits(self.pic2):
            maxBitsColor = self.checkPictureBits(self.pic2)
        # check if pictures have same sizes, if not unify them
        compare = Comparer()
        biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
        if biggerPicture != 0 and smallerPicture != 0:
            self.pic1, self.pic2 = self.getUnifiedPictures()
        # get the values
        tempName = smallerPicture.getPictureName()
        length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
        length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
        pictureName1 = tempName

        result = np.ones((length1, width1), np.uint8)

        fmin = maxBitsColor
        fmax = 0

        for l in range(length1):
            for w in range(width1):
                pom = float(matrix1[l, w]) * alfa + float(matrix2[l, w]) * (1 - alfa)
                result[l, w] = np.ceil(pom)

                # Search for maximum and minimum
                if fmin > pom:
                    fmin = pom
                if fmax < pom:
                    fmax = pom

        # save picture multiplied by picture to png file (without normalization)
        path = self.ex + str(pictureName1) + '_blended_' + str(alfa) + '_' + str(pictureName2) + '.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length1):
            for w in range(width1):
                result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))

        # save picture multiplied by picture to png file (with normalization)
        path = self.ex + str(pictureName1) + '_blended_' + str(alfa) + '_' + str(pictureName2) + '_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Potęgowanie obrazu z zadaną potęgą}
\subsection*{Opis algorytmu}
\par Algorytm potęgowania obrazu szarego do określoną stałej jest szczególnym przypadkiem mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{f(x,y)}{f_{max}}\Big)^{\alpha},  \alpha>0\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/24/fotograf_power_2.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/24/fotograf_power_2_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=2\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/24/rys_power_3.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/24/rys_power_3_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def raiseToPower(self, power):
        length, width, pictureName = self.pic.getPictureParameters()
        matrix = self.pic.getGreyMatrix()
        result = np.zeros((length, width), np.uint8)

        maxPicture = 0
        fmin = maxBitsColor
        fmax = 0

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if maxPicture < pom:
                    maxPicture = pom

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if pom == maxBitsColor:
                    pom = maxBitsColor
                elif pom == 0:
                    pom = 0
                else:
                    pom = np.power(int(pom) / maxPicture, power) * maxBitsColor
                result[l, w] = np.ceil(pom)
                # Search for maximum and minimum
                if fmin > pom:
                    fmin = pom

                if fmax < pom:
                    fmax = pom

        # save picture raised to constant power to png file (without normalization)
        path = self.ex + str(pictureName) + '_power_' + str(power) + '.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length):
            for w in range(width):
                result[l, w] = maxBitsColor * ((result[l, w] - fmin) / (fmax - fmin))

        # save picture raised to constant power to png file (with normalization)
        path = self.ex + str(pictureName) + '_power_' + str(power) + '_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Dzielenie obrazów szarych przez zadaną stałą}
\subsection*{Opis algorytmu}
\par Algorytm dzielenia obrazu szarego przez określoną stałą służy korekcji cieniowania między poziomami szarości obrazu. Aby zastosować algorytm dla każdego piksla obrazu wykonaj:
\begin{enumerate}
\item Policz sumę piksla ze stałą.
\item Spośród obliczonych sum wybierz \(Q_{max}\) - największą sumę.
\item Wartość wynikową policz z następującego wzoru: \[Q[l,w]=(S*255)/Q_{max}\]Wynik zaokrąglij w górę do najbliższej liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/25/fotograf_dividedBy_3.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/25/fotograf_dividedBy_3_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po podzieleniu przez stałą \(\alpha=3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/25/rys_dividedBy_15.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/25/rys_dividedBy_15_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy,obraz po podzieleniu przez stałą \(\alpha=15\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def divideConstGrey(self, constant):
        length, width, matrix, pictureName = self.getPictureParameters(self.pic1)
        result = np.zeros((length, width), np.uint8)

        fmin = maxBitsColor
        fmax = 0
        sumMax = 0

        for l in range(length):
            for w in range(width):
                added = int(matrix[l, w]) + int(constant)
                if sumMax < added:
                    sumMax = added

        for l in range(length):
            for w in range(width):
                added = int(matrix[l, w]) + int(constant)
                pom = (added * maxBitsColor) / sumMax
                result[l, w] = np.ceil(pom)
                if fmin > pom:
                    fmin = pom
                if fmax < pom:
                    fmax = pom

        # save picture with added constant to png file (without normalization)
        path = self.ex + str(pictureName) + '_dividedBy_' + str(constant) + '.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length):
            for w in range(width):
                result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))

        # save picture with added constant to png file (with normalization)
        path = self.ex + str(pictureName) + '_dividedBy_' + str(constant) + '_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Dzielenie obrazu przez inny obraz}
\subsection*{Opis algorytmu}
\begin{enumerate}
\item Policz sumę piksla obrazu \(P_{1}\) z odpowiadającym pikslem obrazu \(P_{2}\).
\item Spośród obliczonych sum wybierz \(Q_{max}\) - największą sumę.
\item Wartość wynikową policz z następującego wzoru: \[Q[l,w]=(S*255)/Q_{max}\]Wynik zaokrąglij w górę do najbliższej liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_rys_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/rys.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/25/fotograf_dividedBy_rys.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/25/fotograf_dividedBy_rys_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz powstały w wyniku dzielenia obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/12/fotograf_AndrzejZamoyski_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/AndrzejZamoyski.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/25/fotograf_dividedBy_AndrzejZamoyski.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/2/25/fotograf_dividedBy_AndrzejZamoyski_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Szary obraz wejściowy 1, szary obraz wejściowy 2 [Od lewej, rząd 2] Obraz powstały w wyniku dzielenia obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
        resolutionUni = ResolutionUnificationGrey(self.name1, self.name2)
        resolutionUni.resolutionUnificationGrey()
        pic1Path, pic2Path = resolutionUni.getOutputPaths()
        pic1 = ImageHelper(pic1Path, self.pictureType)
        pic2 = ImageHelper(pic2Path, self.pictureType)
        return pic1, pic2

def dividePicturesGrey(self):
        if self.checkPictureBits(self.pic1) == self.checkPictureBits(self.pic2):
            maxBitsColor = self.checkPictureBits(self.pic2)
        # check if pictures have same sizes, if not unify them
        compare = Comparer()
        biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
        if biggerPicture != 0 and smallerPicture != 0:
            self.pic1, self.pic2 = self.getUnifiedPictures()
        # get the values
        tempName = smallerPicture.getPictureName()
        length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
        length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
        pictureName1 = tempName

        result = np.ones((length1, width1), np.uint8)

        fmin = maxBitsColor
        fmax = 0
        sumMax = 0

        for l in range(length1):
            for w in range(width1):
                added = int(matrix1[l, w]) + int(matrix2[l, w])
                if sumMax < added:
                    sumMax = added

        for l in range(length1):
            for w in range(width1):
                added = int(matrix1[l, w]) + int(matrix2[l, w])
                pom = (added * maxBitsColor) / sumMax
                result[l, w] = np.ceil(pom)
                if fmin > pom:
                    fmin = pom
                if fmax < pom:
                    fmax = pom

        # save picture multiplied by picture to png file (without normalization)
        path = self.ex + str(pictureName1) + '_dividedBy_' + str(pictureName2) + '.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length1):
            for w in range(width1):
                result[l, w] = maxBitsColor*((result[l, w] - fmin) / (fmax - fmin))

        # save picture multiplied by picture to png file (with normalization)
        path = self.ex + str(pictureName1) + '_dividedBy_' + str(pictureName2) + '_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Pierwiastkowanie obrazu}
\subsection*{Opis algorytmu}
\par Algorytm pierwiastkowania obrazu szarego jest szczególnym przypadkiem wykorzystania algorytmu potęgowania obrazu przez określoną stałą, która jest ułamkiem. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{f(x,y)}{f_{max}}\Big)^{\alpha},  \alpha>0\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/26/fotograf_root_3.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/26/fotograf_root_3_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=1/3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/26/rys_root_2.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/26/rys_root_2_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=1/2\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def rootGrey(self, power):
        factorial = 1 / power
        length, width, pictureName = self.pic.getPictureParameters()
        matrix = self.pic.getGreyMatrix()
        result = np.zeros((length, width), np.uint8)

        maxPicture = 0
        fmin = maxBitsColor
        fmax = 0

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if maxPicture < pom:
                    maxPicture = pom

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if pom == maxBitsColor:
                    pom = maxBitsColor
                elif pom == 0:
                    pom = 0
                else:
                    pom = np.power(int(pom) / maxPicture, factorial) * maxBitsColor
                result[l, w] = np.ceil(pom)
                # Search for maximum and minimum
                if fmin > pom:
                    fmin = pom

                if fmax < pom:
                    fmax = pom

        # save picture raised to constant power to png file (without normalization)
        path = self.ex + str(pictureName) + '_root_' + str(factorial) + '.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length):
            for w in range(width):
                result[l, w] = maxBitsColor * ((result[l, w] - fmin) / (fmax - fmin))

        # save picture raised to constant power to png file (with normalization)
        path = self.ex + str(pictureName) + '_root_' + str(factorial) + '_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Logarytmowanie obrazu}
\subsection*{Opis algorytmu}
\par Algorytm logarytmowania obrazu szarego powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{log(1+f(x,y))}{log(1+f_{max})}\Big)\]Przsunięcie funkcji obrazu o 1 w górę wynika z nieokreśloności logarytmu w zerze.
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/fotograf.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/27/fotograf_log.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/27/fotograf_log_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/rys.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/27/rys_log.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/2/27/rys_log_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def logharitmGrey(self):
        length, width, pictureName = self.pic.getPictureParameters()
        matrix = self.pic.getGreyMatrix()
        result = np.zeros((length, width), np.uint8)

        maxPicture = 0
        fmin = maxBitsColor
        fmax = 0

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if maxPicture < pom:
                    maxPicture = pom

        for l in range(length):
            for w in range(width):
                pom = matrix[l, w]
                if pom == 0:
                    pom = 0
                else:
                    pom = (np.log(1 + pom) / np.log(1 + maxPicture)) * maxBitsColor
                result[l, w] = np.ceil(pom)
                # Search for maximum and minimum
                if fmin > pom:
                    fmin = pom

                if fmax < pom:
                    fmax = pom

        # save picture raised to constant power to png file (without normalization)
        path = self.ex + str(pictureName) + '_log.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)

        for l in range(length):
            for w in range(width):
                result[l, w] = maxBitsColor * ((result[l, w] - fmin) / (fmax - fmin))

        # save picture raised to constant power to png file (with normalization)
        path = self.ex + str(pictureName) + '_log_normalized.png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\chapter{Operacje sumowania arytmetycznego obrazów barwowych}
Operacje arytmtyczne między pikslami dwóch obrazów sa wykorzystywane w wielu działach przetwarzania obrazów. Przeprowadza się je wykonując operacje na pojedynczych pikslach. Po operacjach arytmetycznych zwykle konieczne jest normalizowanie obrazu wynikowego. W zadaniach poruszamy się po przestrzeni barw RGB, a do normalizacji wykorzystano wzór:
\[f_{norm}=Z_{rep}[(f-f_{min})/(f_{max}-f_{min})]\]

\section{Sumowanie obrazów barwowych z określoną stałą}
\subsection*{Opis algorytmu}
\par Algorytm sumowowania obrazu barwowego z określoną stałą polega na dodaniu do 3 kanałów (RGB) każdego pojedynczego piksla określonej stałej. Po operacji sumowania następuje normalizacja obrazu.
\begin{enumerate}
\item Policz sumy wartości każdego piksla w każdym z kanałów ze stałą. Jeżeli suma przekracza 255 to konieczne jest
\begin{itemize}
\item Wybranie największej sumę piksla ze stałą - \(Q_{max}\) 
\item Obliczenie \(D_{max}\) ze wzoru: \(D_{max}[l,w]=(Q_{max}[l,w]-255)\)
\item Obliczenie \(X=D_{max}/255\)
\end{itemize}
\item Policz sumę ze wzoru: \[Q_{R}[l,w]=P_{R}[l,w]-(P_{R}[l, w]*X)+const-(const*X)-1\]\[Q_{G}[l,w]=P_{G}[l,w]-(P_{G}[l, w]*X)+const-(const*X)-1\]\[Q_{B}[l,w]=P_{B}[l,w]-(P_{B}[l, w]*X)+const-(const*X)-1\]
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/31/kawa_constant_20.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/31/kawa_constant_20_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po sumowaniu ze stałą 20, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/31/stogi_constant_200.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/31/stogi_constant_200_normalized.png} }}%
    \caption{[Od lewej] Szary obraz wejściowy, obraz po sumowaniu ze stałą 200, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def addConstRGB(self, constant):
    length, width, pictureName = self.pic1.getPictureParameters()
    matrix = self.pic1.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)

    sumMax = 0
    x = 0
    fmin = 255
    fmax = 0

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0]) + int(constant)
            G = int(matrix[l, w][1]) + int(constant)
            B = int(matrix[l, w][2]) + int(constant)
            if sumMax < max([R, G, B]):
                sumMax = max([R, G, B])

    if sumMax > 255:
        x = (sumMax - 255) / 255

    for l in range(length):
        for w in range(width):
            R = (int(matrix[l, w][0]) - (int(matrix[l, w][0]) * x)) + (int(constant) - (int(constant) * x))
            G = (int(matrix[l, w][1]) - (int(matrix[l, w][1]) * x)) + (int(constant) - (int(constant) * x))
            B = (int(matrix[l, w][2]) - (int(matrix[l, w][2]) * x)) + (int(constant) - (int(constant) * x))
            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)
            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture with added constant to png file (without normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture with added constant to png file (with normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Sumowanie dwóch obrazów barwowych}
\subsection*{Opis algorytmu}
\par Algorytm sumowowania obrazu barwowego z drugim obrazem barwowym jest określone tylko dla obrazów o tych samych wymiarach \(MxN\) i strukturze ich macierzy. Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z  pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu. Po operacji sumowania następuje normalizacja obrazu. Operacja dodawania obrazów są użyteczne przy uśrednianiu obrazów, w celu zredukowania na nich szumu.
\begin{enumerate}
\item Policz sumy wartości składowych barwowych każdego piksla obrazu pierwszego \(P1[l,w]\) z odpowiadającym pikslem drugiego obrazu \(P2[l,w]\)
\item Wybierz największą sumę \(Q_{max}=max(R_{S},G_{S},B_{S})\)
\item Policz sumę ze wzoru: \[Q_{R}[l,w]=(R_{S}*255)/Q_{max}\]\[Q_{G}[l,w]=(G_{S}*255)/Q_{max}\]\[Q_{B}[l,w]=(B_{S}*255)/Q_{max}\]Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/31/morze_added_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/31/morze_added_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, Barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/kawa_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/31/kawa_added_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/31/kawa_added_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, Barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz po sumowaniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
    resolutionUni = ResolutionUnificationRGB(self.name1, self.name2)
    resolutionUni.resolutionUnificationRGB()
    pic1Path, pic2Path = resolutionUni.getOutputPaths()
    pic1 = ImageHelper(pic1Path, self.pictureType)
    pic2 = ImageHelper(pic2Path, self.pictureType)
    return pic1, pic2

def addPictureRGB(self):
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, pictureName1 = self.pic1.getPictureParameters()
    matrix1 = self.pic1.getRGBMatrix()
    length2, width2, pictureName2 = self.pic2.getPictureParameters()
    matrix2 = self.pic2.getRGBMatrix()
    pictureName1 = tempName

    sumMax = 0
    x = 0
    fmax = 0
    fmin = 255

    result = np.zeros((length1, width1, 3), np.uint8)

    for l in range(length1):
        for w in range(width1):
            R = int(matrix1[l, w][0]) + int(matrix2[l, w][0])
            G = int(matrix1[l, w][1]) + int(matrix2[l, w][1])
            B = int(matrix1[l, w][2]) + int(matrix2[l, w][2])
            if sumMax < max([R, G, B]):
                sumMax = max([R, G, B])

    if sumMax > 255:
        x = (sumMax - 255) / 255

    for l in range(length1):
        for w in range(width1):
            R = (int(matrix1[l, w][0]) - (int(matrix1[l, w][0]) * x)) + (int(matrix2[l, w][0]) - (int(matrix2[l, w][0]) * x))
            G = (int(matrix1[l, w][1]) - (int(matrix1[l, w][1]) * x)) + (int(matrix2[l, w][1]) - (int(matrix2[l, w][1]) * x))
            B = (int(matrix1[l, w][2]) - (int(matrix1[l, w][2]) * x)) + (int(matrix2[l, w][2]) - (int(matrix2[l, w][2]) * x))
            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)
            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture with added picture to png file (without normalization)
    path = self.ex + str(pictureName1) + '_added_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    normalized = np.zeros((length1, width1, 3), np.uint8)
    for l in range(length1):
        for w in range(width1):
            normalized[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            normalized[l, w][0] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            normalized[l, w][0] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture with added picture to png file (with normalization)
    path = self.ex + str(pictureName1) + '_added_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mnożenie obrazów barwowych przez określoną stałą}
\subsection*{Opis algorytmu}
\par Algorytm mnożenia obrazu barwowego przez określoną stałą polega na przemnożeniu każdego elementu obrazu (piksla) przez określoną stałą (skalar). Dla wszystkich piksli w obrazie wykonaj na każdym z trzech kanałów RGB:
\begin{enumerate}
\item Jeżeli wartość składowa piksla jest równa 255 to składowa barwowa wynikowa otrzymuje wartość stałej.
\item Jeżeli wartość składowa piksla jest równa 0 to składowa barwowa wynikowa otrzymuje wartość 0.
\item Jeżeli wartość piksla jest inna niż 255 lub 0 to składowa wynikowa otrzymuje wartość poprzez pomnożenie wartości składowej piksla przez skalar, podzielenie przez 255 i zaokrąglenie do liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/morze.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/32/morze_constant_50.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/32/morze_constant_50_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po przmnożeniu ze stałą 50, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/32/stogi_constant_200.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/32/stogi_constant_200_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po przmnożeniu ze stałą 200, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def assignRGBvalue(self, value, factor):
    if value == 255:
        value = factor
    elif value == 0:
        value = 0
    else:
        value = (int(value) * int(factor)) / 255
    return value

def multiplyConstRGB(self, constant):
    length, width, matrix, pictureName = self.getPictureParameters(self.pic1)
    result = np.ones((length, width, 3), np.uint8)

    fmin = 255
    fmax = 0

    for l in range(length):
        for w in range(width):
            R = self.assignRGBvalue(int(matrix[l, w][0]), constant)
            G = self.assignRGBvalue(int(matrix[l, w][1]), constant)
            B = self.assignRGBvalue(int(matrix[l, w][2]), constant)

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)

            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture with added constant to png file (without normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture with added constant to png file (with normalization)
    path = self.ex + str(pictureName) + '_constant_' + str(constant) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mnożenie obrazu przez inny obraz}
\subsection*{Opis algorytmu}
\par Algorytm mnożenia obrazu barwowego przez drugi barwowy obraz o tych samych wymiarach \(MxN\) i strukturze ich macierzy polega na przemnożeniu wartości składowych barwowych piksla z pierwszego obrazu przez odpowiadającą wartość składową barwową piksla z drugiego obrazu. Po operacji mnożenia następuje normalizacja obrazu. Dla każdej wartości składowej barwowej piksla pierwszego obrazu wykonaj następujące czynności:
\begin{enumerate}
\item Jeżeli wartość skaładowa barwowa piksla \(P1[l,w]\) jest równa 255 to składowa wynikowa otrzymuje wartość odpowiadającego piksla drugiego obrazu \(P2[l,w]\).
\item Jeżeli wartość skaładowa barwowa piksla \(P1[l,w]\) jest równa 0 to składowa wynikowa otrzymuje wartość 0.
\item Jeżeli wartość skaładowa barwowa piksla \(P1[l,w]\) jest inna niż 255 lub 0 to składowa wynikowa otrzymuje wartość poprzez pomnożenie wartości barwowej piksla \(P1[l,w]\) przez odpowiadającą barwową piksla \(P2[l,w]\), podzielenie przez 255 i zaokrąglenie do liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/32/morze_multiplied_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/32/morze_multiplied_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz po mnożeniu obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
    resolutionUni = ResolutionUnificationRGB(self.name1, self.name2)
    resolutionUni.resolutionUnificationRGB()
    pic1Path, pic2Path = resolutionUni.getOutputPaths()
    pic1 = ImageHelper(pic1Path, self.pictureType)
    pic2 = ImageHelper(pic2Path, self.pictureType)
    return pic1, pic2

def assignRGBvalue(self, value, factor):
    if value == 255:
        value = factor
    elif value == 0:
        value = 0
    else:
        value = (int(value) * int(factor)) / 255
    return value
    
def multiplyPicturesRGB(self):
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
    length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
    pictureName1 = tempName

    result = np.ones((length1, width1, 3), np.uint8)

    fmin = 255
    fmax = 0

    for l in range(length1):
        for w in range(width1):
            R = self.assignRGBvalue(int(matrix1[l, w][0]), int(matrix2[l, w][0]))
            G = self.assignRGBvalue(int(matrix1[l, w][1]), int(matrix2[l, w][1]))
            B = self.assignRGBvalue(int(matrix1[l, w][2]), int(matrix2[l, w][2]))

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)

            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture multiplied by picture to png file (without normalization)
    path = self.ex + str(pictureName1) + '_multiplied_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length1):
        for w in range(width1):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture multiplied by picture to png file (with normalization)
    path = self.ex + str(pictureName1) + '_multiplied_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Mieszanie obrazów z określonym współczynnikiem}
\subsection*{Opis algorytmu}
\par Mieszanie dwóch obrazów polega na sumowaniu ich z wagami \(\alpha\) i \(1-\alpha\) według wzoru: \[f_{m}=f\alpha+f^{I}(1-\alpha)\] gdzie \(\alpha\in[0,1]\). Płynna zmiana parametru \(\alpha\) w przedziale \([0,1]\) powoduje efekt przechodzenia obrazu \(f\) w obraz \(f^{I}\).
\begin{enumerate}
\item Weź dwa obrazy barwowe o takim samym rozmiarze (po ujednoliceniu rozdzielczościowym) \(P_{1}\) i \(P_{2}\).
\item Określ współczynnik mieszania obrazów \(\alpha\) wyrażony jako liczba rzeczywista z przedziału \([0,1]\), gdzie 0 reprezentuje przezroczystość, a 1 reprezentuje nieprzezroczystość.
\item Dla wszystkich piksli w obrazach wejściowych wykonaj: \[Q[l,w]=\alpha*P_{1}[l,w]+(1-\alpha)*P_{2}[l,w]\]
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/kawa_morze_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/morze.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/33/kawa_blended_0.6_morze.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/33/kawa_blended_0.6_morze_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz po mieszaniu ze współczynnikiem \(\alpha=0.6\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/33/morze_blended_0.3_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/33/morze_blended_0.3_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz po mieszaniu ze współczynnikiem \(\alpha=0.3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
    resolutionUni = ResolutionUnificationRGB(self.name1, self.name2)
    resolutionUni.resolutionUnificationRGB()
    pic1Path, pic2Path = resolutionUni.getOutputPaths()
    pic1 = ImageHelper(pic1Path, self.pictureType)
    pic2 = ImageHelper(pic2Path, self.pictureType)
    return pic1, pic2

def blendPictures(self, alfa):
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
    length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
    pictureName1 = tempName

    result = np.ones((length1, width1, 3), np.uint8)

    fmin = 255
    fmax = 0

    for l in range(length1):
        for w in range(width1):
            R = (float(matrix1[l, w][0]) * alfa) + (float(matrix2[l, w][0]) * (1 - alfa))
            G = (float(matrix1[l, w][1]) * alfa) + (float(matrix2[l, w][1]) * (1 - alfa))
            B = (float(matrix1[l, w][2]) * alfa) + (float(matrix2[l, w][2]) * (1 - alfa))

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)

            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture multiplied by picture to png file (without normalization)
    path = self.ex + str(pictureName1) + '_blended_' + str(alfa) + '_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length1):
        for w in range(width1):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture multiplied by picture to png file (with normalization)
    path = self.ex + str(pictureName1) + '_blended_' + str(alfa) + '_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Potęgowanie obrazu z zadaną potęgą}
\subsection*{Opis algorytmu}
\par Algorytm potęgowania obrazu barwowego do określoną stałej jest szczególnym przypadkiem mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{f(x,y)}{f_{max}}\Big)^{\alpha},  \alpha>0\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/34/kawa_power_3.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/34/kawa_power_3_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=2\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/34/stogi_power_5.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/34/stogi_power_5_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=5\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def raiseToPower(self, power):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)

    maxPicture = 0
    fmin = 255
    fmax = 0

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])
            if maxPicture < max([R, G, B]):
                maxPicture = max([R, G, B])

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])

            if R == 0:
                R = 0
            else:
                R = np.power(int(R) / maxPicture, power) * 255

            if G == 0:
                G = 0
            else:
                G = np.power(int(G) / maxPicture, power) * 255

            if B == 0:
                B = 0
            else:
                B = np.power(int(B) / maxPicture, power) * 255

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)

            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture raised to constant power to png file (without normalization)
    path = self.ex + str(pictureName) + '_power_' + str(power) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture raised to constant power to png file (with normalization)
    path = self.ex + str(pictureName) + '_power_' + str(power) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Dzielenie obrazów barwowych przez zadaną stałą}
\subsection*{Opis algorytmu}
\par Algorytm dzielenia obrazu barwowego przez określoną stałą służy korekcji cieniowania między poziomami szarości obrazu. Aby zastosować algorytm dla każdego piksla obrazu wykonaj:
\begin{enumerate}
\item Policz sumy warytości składowych barwowych piksla ze stałą.
\item Spośród obliczonych sum wybierz \(Q_{max}=max(R_{S},G_{S},B_{S})\) - największą sumę.
\item Wartość wynikową policz z następującego wzoru: \[Q_{R}[l,w]=(R_{S}*255)/Q_{max}\]\[Q_{G}[l,w]=(G_{S}*255)/Q_{max}\]\[Q_{B}[l,w]=(B_{S}*255)/Q_{max}\]Wynik zaokrąglij w górę do najbliższej liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/35/kawa_dividedBy_7.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/35/kawa_dividedBy_7_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po podzieleniu przez stałą \(\alpha=7\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/35/stogi_dividedBy_3.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/35/stogi_dividedBy_3_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy,obraz po podzieleniu przez stałą \(\alpha=3\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def divideConstRGB(self, constant):
    length, width, matrix, pictureName = self.getPictureParameters(self.pic1)
    result = np.zeros((length, width, 3), np.uint8)

    fmin = 255
    fmax = 0
    sumMax = 0

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0]) + int(constant)
            G = int(matrix[l, w][1]) + int(constant)
            B = int(matrix[l, w][2]) + int(constant)
            if sumMax < max([R, G, B]):
                sumMax = max([R, G, B])

    for l in range(length):
        for w in range(width):
            R_pom = int(matrix[l, w][0]) + int(constant)
            G_pom = int(matrix[l, w][1]) + int(constant)
            B_pom = int(matrix[l, w][2]) + int(constant)

            R = (R_pom * 255) / sumMax
            G = (G_pom * 255) / sumMax
            B = (B_pom * 255) / sumMax

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)
            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    path = self.ex + str(pictureName) + '_dividedBy_' + str(constant) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    path = self.ex + str(pictureName) + '_dividedBy_' + str(constant) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Dzielenie obrazu przez inny obraz}
\subsection*{Opis algorytmu}
\begin{enumerate}
\item Policz sumę wartości składowej barwowej piksla obrazu \(P_{1}\) z odpowiadającym wartością składową piksla obrazu \(P_{2}\).
\item Spośród obliczonych sum wybierz \(Q_{max}=max(R_{S},G_{S},B_{S})\) - największą sumę.
\item Wartość wynikową policz z następującego wzoru: \[Q_{R}[l,w]=(R_{S}*255)/Q_{max}\]\[Q_{G}[l,w]=(G_{S}*255)/Q_{max}\]\[Q_{B}[l,w]=(B_{S}*255)/Q_{max}\]Wynik zaokrąglij w górę do najbliższej liczby całkowitej.
\end{enumerate}
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/kawa_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/35/kawa_dividedBy_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/35/kawa_dividedBy_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz powstały w wyniku dzielenia obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/1/14/morze_stogi_withInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/35/morze_dividedBy_stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/3/35/morze_dividedBy_stogi_normalized.png} }}%
    \caption{[Od lewej, rząd 1] Barwowy obraz wejściowy 1, barwowy obraz wejściowy 2 [Od lewej, rząd 2] Obraz powstały w wyniku dzielenia obrazów 1 i 2, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def getUnifiedPictures(self):
    resolutionUni = ResolutionUnificationRGB(self.name1, self.name2)
    resolutionUni.resolutionUnificationRGB()
    pic1Path, pic2Path = resolutionUni.getOutputPaths()
    pic1 = ImageHelper(pic1Path, self.pictureType)
    pic2 = ImageHelper(pic2Path, self.pictureType)
    return pic1, pic2

def dividePicturesRGB(self):
    compare = Comparer()
    biggerPicture, smallerPicture = compare.comparePictures(self.pic1, self.pic2)
    if biggerPicture != 0 and smallerPicture != 0:
        self.pic1, self.pic2 = self.getUnifiedPictures()
    # get the values
    tempName = smallerPicture.getPictureName()
    length1, width1, matrix1, pictureName1 = self.getPictureParameters(self.pic1)
    length2, width2, matrix2, pictureName2 = self.getPictureParameters(self.pic2)
    pictureName1 = tempName

    result = np.ones((length1, width1, 3), np.uint8)

    fmin = 255
    fmax = 0
    sumMax = 0

    for l in range(length1):
        for w in range(width1):
            R = int(matrix1[l, w][0]) + int(matrix2[l, w][0])
            G = int(matrix1[l, w][1]) + int(matrix2[l, w][1])
            B = int(matrix1[l, w][2]) + int(matrix2[l, w][2])
            if sumMax < max([R, G, B]):
                sumMax = max([R, G, B])

    for l in range(length1):
        for w in range(width1):
            R_pom = int(matrix1[l, w][0]) + int(matrix2[l, w][0])
            G_pom = int(matrix1[l, w][1]) + int(matrix2[l, w][1])
            B_pom = int(matrix1[l, w][2]) + int(matrix2[l, w][2])

            R = (R_pom * 255) / sumMax
            G = (G_pom * 255) / sumMax
            B = (B_pom * 255) / sumMax

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)
            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture divided by picture to png file (without normalization)
    path = self.ex + str(pictureName1) + '_dividedBy_' + str(pictureName2) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    normalized = np.zeros((length1, width1, 3), np.uint8)
    for l in range(length1):
        for w in range(width1):
            normalized[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            normalized[l, w][0] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            normalized[l, w][0] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture divided by picture to png file (with normalization)
    path = self.ex + str(pictureName1) + '_dividedBy_' + str(pictureName2) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Pierwiastkowanie obrazu}
\subsection*{Opis algorytmu}
\par Algorytm pierwiastkowania obrazu barwowego jest szczególnym przypadkiem wykorzystania algorytmu potęgowania obrazu przez określoną stałą, która jest ułamkiem. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{f(x,y)}{f_{max}}\Big)^{\alpha},  \alpha>0\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/36/kawa_root_2.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/36/kawa_root_2_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=1/2\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/36/stogi_root_6.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/36/stogi_root_6_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po podniesieniu do potęgi \(\alpha=1/6\), obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def rootRGB(self, power):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)
    factorial = 1 / power

    maxPicture = 0
    fmin = 255
    fmax = 0

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])
            if maxPicture < max([R, G, B]):
                maxPicture = max([R, G, B])

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])

            if R == 0:
                R = 0
            else:
                R = np.power(int(R) / maxPicture, factorial) * 255

            if G == 0:
                G = 0
            else:
                G = np.power(int(G) / maxPicture, factorial) * 255

            if B == 0:
                B = 0
            else:
                B = np.power(int(B) / maxPicture, factorial) * 255

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)

            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture raised to constant factorial to png file (without normalization)
    path = self.ex + str(pictureName) + '_root_' + str(power) + '.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture raised to constant factorial to png file (with normalization)
    path = self.ex + str(pictureName) + '_root_' + str(power) + '_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Logarytmowanie obrazu}
\subsection*{Opis algorytmu}
\par Algorytm logarytmowania obrazu barwowego powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru: \[f_{m}=255*\Big(\frac{log(1+f(x,y))}{log(1+f_{max})}\Big)\]Przsunięcie funkcji obrazu o 1 w górę wynika z nieokreśloności logarytmu w zerze.
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/morze.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/37/morze_log.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/37/morze_log_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/37/stogi_log.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/3/37/stogi_log_normalized.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
    def logharitmRGB(self):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)

    maxPicture = 0
    fmin = 255
    fmax = 0

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])
            if maxPicture < max([R, G, B]):
                maxPicture = max([R, G, B])

    for l in range(length):
        for w in range(width):
            R = int(matrix[l, w][0])
            G = int(matrix[l, w][1])
            B = int(matrix[l, w][2])

            if R == 0:
                R = 0
            else:
                R = (np.log(1 + R) / np.log(1 + maxPicture)) * 255

            if G == 0:
                G = 0
            else:
                G = (np.log(1 + G) / np.log(1 + maxPicture)) * 255

            if B == 0:
                B = 0
            else:
                B = (np.log(1 + B) / np.log(1 + maxPicture)) * 255

            result[w, l][0] = np.ceil(R)
            result[w, l][1] = np.ceil(G)
            result[w, l][2] = np.ceil(B)
            # Search for maximum and minimum
            if fmin > min([R, G, B]):
                fmin = min([R, G, B])
            if fmax < max([R, G, B]):
                fmax = max([R, G, B])

    # save picture raised to constant power to png file (without normalization)
    path = self.ex + str(pictureName) + '_log.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)

    for l in range(length):
        for w in range(width):
            result[l, w][0] = 255 * ((result[l, w][0] - fmin) / (fmax - fmin))
            result[l, w][1] = 255 * ((result[l, w][1] - fmin) / (fmax - fmin))
            result[l, w][2] = 255 * ((result[l, w][2] - fmin) / (fmax - fmin))

    # save picture raised to constant power to png file (with normalization)
    path = self.ex + str(pictureName) + '_log_normalized.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\chapter{Operacje geometryczne na obrazie}
Operacje geometryczne na obrazach są szczególnie wykorzystywane w przypadku dopasowywania obrazu do układu współrzędnych oraz w przypadku eliminowania zniekształceń geometrycznych obrazu. W przedstawionych operacjach obrazy umieszczone są w pierwszej ćwiartce układu współrzędnych.
\section{Przemieszczanie obrazu o zadany wektor}
\subsection*{Opis algorytmu}
\par Przemieszczanie obrazu o dany wektor polega na przesunięciu każdego piksla obrazu o określoną wartość zgodnie z zależnościami:\[x^{I}=x_{o}+\Delta x\]\[y^{I}=y_{o}+\Delta y\]gdzie \((x_{o},y_{o})\) są współrzędnymi początkowymi piksla, \((\Delta x,\Delta y)\) są wartościami przesunięcia, a  \((x^{I},y^{I})\) są współrzędnymi piksla po przesunięciu.
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/4/41/kawa_moved_[30,80].png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po przesunięciu o wektor [30, 80]}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.4\textwidth]{./RawPictures/stogi.png} }}%
    \subfloat{{\includegraphics[width=0.4\textwidth]{./ExEffects/4/41/stogi_moved_[100,10].png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po przesunięciu o wektor [100, 10]}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def relocateByVectorRGB(self, x, y):
        length, width, pictureName = self.pic.getPictureParameters()
        matrix = self.pic.getRGBMatrix()
        deltaX = 0 - x
        result = np.zeros((length, width, 3), np.uint8)

        for l in range(length):
            for w in range(width):
                if 0 < l + y < length and 0 < w + deltaX < width:
                    result[w + deltaX, l + y] = matrix[l, w]

        path = self.ex + str(pictureName) + '_moved_[' + str(x) + ',' + str(y) + '].png'
        self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Skalowanie jednorodne obrazu}
\subsection*{Opis algorytmu}
\par Skalowanie jednorodne obrazu polega na pomnożeniu każdego piksla obrazu przez współczynnik skalowanie \(S\) według zależności:\[x^{I}=x_{o}*S\]\[y^{I}=y_{o}*S\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/morze.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/morze_homogeneous_1.5_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/morze_homogeneous_1.5_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po skalowaniu jednorodnym ze współczynnikiem \(S=1.5\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/tecza.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/tecza_homogeneous_2_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/tecza_homogeneous_2_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po skalowaniu jednorodnym ze współczynnikiem \(S=2\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def homogeneousScalingRGB(self, scale):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)
    for l in range(length):
        for w in range(width):
            if scale * l < length and scale * w < width:
                result[int(scale * w), int(scale * l)] = matrix[l, w]
    path = self.ex + str(pictureName) + '_homogeneous_' + str(scale) + '_withoutInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
    for l in range(length):
        for w in range(width):
            r, g, b = 0, 0, 0
            n = 1
            if result[l, w][0] < 1 and result[l, w][1] < 1 and result[l, w][2] < 1:
                for lOff in range(-1, 2):
                    for wOff in range(-1, 2):
                        lSave = l if ((l + lOff) > (length - 2)) | ((l + lOff) < 0) else (l + lOff)
                        wSave = w if ((w + wOff) > (width - 2)) | ((w + wOff) < 0) else (w + wOff)
                        if result[lSave, wSave][0] > 0 or result[lSave, wSave][1] > 0 or result[lSave, wSave][2] > 0:
                            r += result[lSave, wSave][0]
                            g += result[lSave, wSave][1]
                            b += result[lSave, wSave][2]
                            n += 1
                result[l, w] = (r / n, g / n, b / n)
    path = self.ex + str(pictureName) + '_homogeneous_' + str(scale) + '_withInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Skalowanie niejednorodne obrazu}
\subsection*{Opis algorytmu}
\par Skalowanie niejednorodne obrazu polega na pomnożeniu każdego piksla obrazu przez współczynnik skalowanie \(S_{x}\), \(S_{y}\) według zależności:\[x^{I}=x_{o}*S_{x}\]\[y^{I}=y_{o}*S_{y}\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/morze.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/morze_heterogeneous_[3,1]_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/morze_heterogeneous_[3,1]_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po skalowaniu niejednorodnym ze współczynnikiem \(S_{x}=3\) i  \(S_{y}=1\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/tecza.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/tecza_heterogeneous_[1,3]_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/42/tecza_heterogeneous_[1,3]_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po skalowaniu niejednorodnym ze współczynnikiem \(S_{x}=1\) i  \(S_{y}=3\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def heterogeneousScalingRGB(self, scaleY, scaleX):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.zeros((length, width, 3), np.uint8)
    for l in range(length):
        for w in range(width):
            if scaleY * l < length and scaleX * w < width:
                result[int(scaleX * w), int(scaleY * l)] = matrix[l, w]
    path = self.ex + str(pictureName) + '_heterogeneous_[' + str(scaleY) + ',' + str(
        scaleX) + ']_withoutInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
    for l in range(length):
        for w in range(width):
            r, g, b = 0, 0, 0
            n = 0
            if result[l, w][0] < 1 and result[l, w][1] < 1 and result[l, w][2] < 1:
                for lOff in range(-1, 2):
                    for wOff in range(-1, 2):
                        lSave = l if ((l + lOff) > (length - 2)) | ((l + lOff) < 0) else (l + lOff)
                        wSave = w if ((w + wOff) > (width - 2)) | ((w + wOff) < 0) else (w + wOff)
                        if result[lSave, wSave][0] > 0 or result[lSave, wSave][1] > 0 or result[lSave, wSave][
                            2] > 0:
                            r += result[lSave, wSave][0]
                            g += result[lSave, wSave][1]
                            b += result[lSave, wSave][2]
                            n += 1
                result[l, w] = (r / n, g / n, b / n)
    path = self.ex + str(pictureName) + '_heterogeneous_[' + str(scaleY) + ',' + str(
        scaleX) + ']_withInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Obracanie obrazu o dowolny kąt}
\subsection*{Opis algorytmu}
\par Obracanie obrazu o dowolny kąt dookoła początku układu współrzędnych wykonuje się zgodnie ze wzorem: \[x^{I}=x_{o}*cos\alpha-y_{o}*sin\alpha\]\[y^{I}=x_{o}*sin\alpha-y_{o}*con\alpha\]gdzie \((x_{o},y_{o})\) - współrzędne początkowe piksla, \(\alpha\) to kąt obrotu, \((x^{I},y^{I})\) to współrzędne piksla po obrocie.
\par W przedstawionych przykładach punkt obrotu został przesunięty na środek obrazu według wzoru:\[new_{x}=(x-width/2)*cos(\alpha_{r})-(y-height/2)*sin(\alpha_{r})+(width/2)\]\[new_{y}=(x-width/2)*sin(\alpha_{r})+(y-height/2)*cos(\alpha_{r})+(height/2)\]
\subsection*{Efekty wykorzystania algorytmu}
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/morze.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/43/morze_angle_60_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/43/morze_angle_60_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po obrocie o kąt \(\alpha=60^{o}\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\begin{figure}[h]
    \centering
    \subfloat{{\includegraphics[width=0.3\textwidth]{./RawPictures/kawa.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/43/kawa_angle_45_withoutInterpolation.png} }}%
    \subfloat{{\includegraphics[width=0.3\textwidth]{./ExEffects/4/43/kawa_angle_45_withInterpolation.png} }}%
    \caption{[Od lewej] Barwowy obraz wejściowy, obraz po obrocie o kąt \(\alpha=45^{o}\), obraz po interpolacji}%
    \label{fig:geo_after_grey1}%
\end{figure}
\FloatBarrier
\subsection*{Kod źródłowy algorytmu}
\begin{lstlisting}[language=Python]
def angleRGB(self, angle):
    length, width, pictureName = self.pic.getPictureParameters()
    matrix = self.pic.getRGBMatrix()
    result = np.ones((length, width, 3), np.uint8)
    angleRadians = np.radians(angle)
    for l in range(length):
        for w in range(width):
            newW = (w - width / 2) * np.cos(angleRadians) - (l - length / 2) * np.sin(angleRadians) + (width / 2)
            newL = (w - width / 2) * np.sin(angleRadians) + (l - length / 2) * np.cos(angleRadians) + (length / 2)
            if 0 <= newL < length and 0 <= newW < width:
                result[int(newL), int(newW)] = matrix[l, w]
    path = self.ex + str(pictureName) + '_angle_' + str(angle) + '_withoutInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
    for l in range(length):
        for w in range(width):
            r, g, b = 0, 0, 0
            n = 1
            if result[l, w][0] == 1 and result[l, w][1] == 1 and result[l, w][2] == 1:
                for lOff in range(-1, 2):
                    for wOff in range(-1, 2):
                        lSave = l if ((l + lOff) > (length - 2)) | ((l + lOff) < 0) else (l + lOff)
                        wSave = w if ((w + wOff) > (width - 2)) | ((w + wOff) < 0) else (w + wOff)
                        if result[lSave, wSave][0] > 1 or result[lSave, wSave][1] > 1 or result[lSave, wSave][
                            2] > 1:
                            r += result[lSave, wSave][0]
                            g += result[lSave, wSave][1]
                            b += result[lSave, wSave][2]
                            n += 1
                result[l, w] = (r / n, g / n, b / n)
    path = self.ex + str(pictureName) + '_angle_' + str(angle) + '_withInterpolation.png'
    self.saver.savePictureFromArray(result, self.pictureType, path)
\end{lstlisting}

\section{Symetrie obrazu}
\subsection{Symetra względem osi OX}
\subsection{Symetria względem osi OY}
\subsection{Symetria względem zadanej prostej}
\section{Wycinanie fragmentów obrazów}
\section{Kopiowanie fragmentów obrazów}

\chapter{Operacje na histogramie obrazu szarego}
\section{Obliczanie histogramu}
\section{Przemieszczanie histogramu}
\section{Rozciąganie histogramu}
\section{Progowanie lokalne}
\section{Progowanie globalne}

\chapter{Operacje na histogramie obrazu barwowego}
\section{Obliczanie histogramu}
\section{Przemieszczanie histogramu}
\section{Rozciąganie histogramu}
\section{Progowanie 1 progowe lokalne}
\section{Progowanie 1 progowe globalne}
\section{Progowanie wieloprogowe lokalne}
\section{Progowanie wieloprogowe globalne}

\end{document}
